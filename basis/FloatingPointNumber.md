# Floating Point Number Introduction

## 浮点数定义

> 在计算机领域，浮点数的「浮点」就是指，其小数点的位置是可以是漂浮不定的。
<br />
> 
浮点数是采用类似数学上的科学计数法来表示，例如十进制小数`8.345`，用科学计数法表示，可以有多种方式。
```text
8.345 = 8.345 * 10^0
8.345 = 83.45 * 10^-1
8.345 = 834.5 * 10^-2
...
```
> 进一步可以得到如下浮点数表示数字的公式
```text
V = (-1)^S * M * R^E
```
- S：符号位，取值`0`或`1`，`0`表示正数，`1`表示负数
- M：尾数，用小数表示，例如前面例子看到的`8.345*10^0`，`8.345`就是尾数
- R：基数，表示十进制数时，`R`就是`10`，表示二进制数时`R`就是`2`
- E：指数，用整数表示，例如前面例子看到的`10^-1`，`-1`即是指数
> 在计算机中用浮点数表示一个数字，只需要确认这几个变量即可。
![32bit表示浮点数](https://github.com/jiaojiaodamowang/sutra-repository/blob/main/basis/resource/32bit_floating_point_number.jpg)
- 符号位`S`占`1`bit
- 指数`E`占`10`bit
- 尾数`M`占`21`bit

> 根据这个规则，将十进制数`25.125`转换为浮点数，转换过程就是这样的（D代表十进制，B代表二进制）：
1. 整数部分：25(D) = 11001(B)
2. 小数部分：0.125(D) = 0.001(B)
3. 用二进制科学计数法表示：25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B)
4. 所以符号位`S`= 0，尾数`M`= 1.001001(B)，指数`E`= 4(D) = 100(B)。

填充后的32bit数据
![32bit表示浮点数2](https://github.com/jiaojiaodamowang/sutra-repository/blob/main/basis/resource/32bit_floating_point_number2.jpg)
> 根据刚才定义的规则，符号位`S`占`1`bit，指数位`E`占`10`bit，尾数`M`占 21 bit，这个规则是我们拍脑袋随便定义出来的。
> 如果用一个新规则，如符号位`S`占`1`bit，指数位`E`占`5`bit，尾数`M`占`25`bit，是否也可以？当然可以。

按这个规则来，那浮点数表示出来就是这样
![32bit表示浮点数3](https://github.com/jiaojiaodamowang/sutra-repository/blob/main/basis/resource/32bit_floating_point_number3.jpg)
> 观察后得到以下结论
1. 指数位越多，尾数位则越少，其表示的范围越大，但精度就会变差，反之，指数位越少，尾数位则越多，表示的范围越小，但精度就会变好。
2. 一个数字的浮点数格式，会因为定义的规则不同，得到的结果也不同，表示的范围和精度也有差异。

## 浮点数标准

直到1985年，`IEEE`组织推出了浮点数标准，就是我们经常听到的`IEEE754`浮点数标准，这个标准统一了浮点数的表示形式，并提供了 2 种浮点格式：
- 单精度浮点数：共`32`位，其中符号位`S`占`1`bit，指数`E`占`8`bit，尾数`M`占`23`bit
- 双精度浮点数：共`64`位，其中符号位`S`占`1`bit，指数`E`占`11`bit，尾数`M`占`52`bit

为了使其表示的数字范围、精度最大化，浮点数标准还对指数和尾数进行了规定：
- 尾数`M`的第一位总是`1`（因为 1 <= M < 2），因此这个`1`可以省略不写，它是个隐藏位，这样单精度`23`位尾数可以表示了 24 位有效数字，双精度`52`位尾数可以表示 53 位有效数字
- 指数`E`是个无符号整数，表示`单精度浮点数`时，一共占`8`bit，所以它的取值范围为`0 ~ 255`。但因为指数可以是负的，所以规定在存入`E`时在它原本的值加上一个中间数`127`，这样`E`的取值范围为`-127 ~ 128`。表示`双精度浮点数`时，一共占`11`bit，存入`E`时加上中间数`1023`，这样取值范围为`-1023 ~ 1024`

除了规定尾数和指数位，还做了以下规定：

- 指数`E`非全`0`并且非全`1`：规格化数字，按上面的规则正常计算
- 指数`E`全`0`，尾数`M`非`0`：非规格化数，尾数隐藏位不再是`1`，而是`0`(M = 0.xxxxx)，这样可以表示`0`和很小的数
- 指数`E`全`1`，尾数全`0`：正无穷大/负无穷大（正负取决于`S`符号位）
- 指数`E`全`1`，尾数非`0`：NaN(Not a Number)

![32bit表示浮点数4](https://github.com/jiaojiaodamowang/sutra-repository/blob/main/basis/resource/32bit_floating_point_number4.jpg)

## 浮点数表示

有了这个统一的浮点数标准，再把`25.125`转换为标准的`单精度浮点数`：

1. 整数部分：25(D) = 11001(B)
2. 小数部分：0.125(D) = 0.001(B)
3. 用二进制科学计数法表示：25.125(D) = 11001.001(B) = 1.1001001 * 2^4(B)

所以`S`= 0 ，尾数`M`= 1.1001001 = 1001001(去掉1，隐藏位)，指数`E`= 4 + 127(中间数) = 135(D) = 10000011(B)。填充到 32 bit 中，如下：

![32bit表示浮点数5](https://github.com/jiaojiaodamowang/sutra-repository/blob/main/basis/resource/32bit_floating_point_number5.jpg)
<font color=red>*原图数据有误</font>

## 精度损失
> 如果现在想用浮点数表示`0.2`，它的结果会是多少呢？

`0.2`转换为二进制数的过程为，不断乘以`2`，直到不存在小数为止，在这个计算过程中，得到的整数部分从上到下排列就是二进制的结果。

```text
0.2 * 2 = 0.4 -> 0
0.4 * 2 = 0.8 -> 0
0.8 * 2 = 1.6 -> 1
0.6 * 2 = 1.2 -> 1
0.2 * 2 = 0.4 -> 0（发生循环）
...
```
故 `0.2`(D) = `0.00110…`(B)。

因为十进制的`0.2`无法精确转换成二进制小数，而计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。

> 浮点数的范围和精度有多大？

- `单精度浮点数（Float）`的尾数`M`占`23`bit，算上小数点前的隐藏位共`24`bit，得到在十进制下log10(2^24)≈`7.22`位。
- `双精度浮点数（Double）`的尾数`M`占`53`bit，算上小数点前的隐藏位共`54`bit，得到在十进制下log10(2^54)≈`15.96`位。
- `单精度浮点数（Float）`的指数`E`占`8`bit，`双精度浮点数（Double）`的指数`E`占`11`bit，故`双精度浮点数（Double）`可表示的数值范围也更大。

## Reference
- [BinaryConvert](http://www.binaryconvert.com/)